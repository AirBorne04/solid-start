---
section: core-concepts
title: API Routes
order: 8
---

# API Routes

While we think that using tools like `createServerData$` are the best way to write server-side code for data needed by your UI, sometimes you need to expose API routes. This could be for a variety of reasons:

* You have additional clients that want to share this logic
* You want to expose a GraphQL or TRPC endpoint
* You want to expose a public facing REST API
* You need to write webhooks or auth callback handlers for OAuth
* You want to have URLs not serving HTML, but other kinds of documents like PDFs or images


SolidStart makes it easy to write these kinds of routes as well.

## Writing an API Route

API routes are just like any other route and follow the same filename conventions as pages. The only difference is in what you export from the file. Instead of exporting a default `Page` component and a `routeData` function, API Routes export functions that are named after the HTTP method that they handle.

```tsx twoslash filename="/routes/api/students.ts"
// handles HTTP GET requests to /api/students
export function GET() {
  return new Response("Hello World");
}

export function POST() {
  // ...
}

export function PATCH() {
  // ...
}

export function DELETE() {
  // ...
}
```

These functions can also sit in your UI routes besides your component. They can handle non-GET HTTP requests for those routes.

```tsx twoslash filename="/routes/students.tsx"
export function POST() {
  // ...
}

export function routeData() {
  // ...
}

export default function Students() {
  return <h1>Students</h1>;
}

```

Warning: A route can only export either a default `Page` component or a `GET` handler. You cannot export both.

An API route gets passed an `APIEvent` object as its first argument. This object contains:
* `request`: the `Request` object representing the request sent by the client
* `params`: object that contains the dynamic route parameters, eg. for `/api/students/:id`, when user requests `/api/students/123` , `params.id` will be `"123"`
* `env`: the environment context, environment specific settings, bindings
* `fetch`: an internal `fetch` function that can be used to make requests to other API routes without worrying about the `origin` of the URL.

Lets look at an example of an API route that returns a list of students in a given house, in a specific year:

```tsx twoslash filename="/routes/api/[house]/students/year-[year].ts"
// @filename: hogwarts.ts
export default {
  getStudents(house: string, year: string) {
    return [
      { name: "Harry Potter", house, year },
      { name: "Hermione Granger", house, year },
      { name: "Ron Weasley", house, year },
    ];
  },
};


// @filename: index.ts
// ---cut---
import { ApiFetchEvent, json } from "solid-start/api";
import hogwarts from "./hogwarts";

export async function GET({ params }: ApiFetchEvent) {
  console.log(`House: ${params.house}, Year: ${params.year}`);
  const students = await hogwarts.getStudents(params.house, params.year);
  return json({ students })
}
```

As HTTP is a stateless protocol, for awesome dynamic experiences, you want to know the state of the session on the client. For example, you want to know who the user is. The secure way of doing this is to use HTTP-only cookies. You can store session data in them and they are persisted by the browser that your user is using. 

We expose the `Request` object which represents the user's request. The cookies can be accessed by parsing the `Cookie` header in the client. Let's look at an example of how to use the cookie to identify the user:

```tsx twoslash filename="/routes/api/[house]/admin.ts"
// @filename: hogwarts.ts
export default {
  getStudents(house: string, year: string) {
    return [
      { name: "Harry Potter", house, year },
      { name: "Hermione Granger", house, year },
      { name: "Ron Weasley", house, year },
    ];
  },
  getHouseMaster(house: string) {
    return {
      name: "Severus Snape",
      house,
      id: "5"
    };
  },
};


// @filename: index.ts
// ---cut---
import { ApiFetchEvent, json } from "solid-start/api";
import { parseCookie } from "solid-start";
import hogwarts from "./hogwarts";

export async function GET({ request, params }: ApiFetchEvent) {
  const cookie = parseCookie(request.headers.get("Cookie") ?? "");
  const userId = cookie['userId'];
  if (!userId) {
    return new Response("Not logged in", { status: 401 });
  }
  const houseMaster = await hogwarts.getHouseMaster(params.house);
  if (houseMaster.id !== userId) {
    return new Response("Not authorized", { status: 403 });
  }
  return json({ 
    students: await hogwarts.getStudents(params.house, params.year) 
  })
}
```

This is a very simple example and quite unsecure, but you can see how you can use cookies to read and store session data. Read the [session][session] documentation for more information on how to use cookies for more secure session management.

You can read more about using HTTP cookies in the [MDN documentation][cookies]


[cookies]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
[session]: /advanced/session